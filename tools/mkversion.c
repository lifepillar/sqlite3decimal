/**
 * \file mkversion.c
 *
 * \brief Generates version.h from Fossil's manifest files and Makefile.
 *
 * This C program is used to generate src/version.h from information extracted
 * out of the `manifest`, `manifest.uuid`, and `VERSION` files. Intended usage:
 *
 *     ./tools/mkversion manifest.uuid manifest VERSION >src/version.h
 *
 * Note that the `manifest.uuid` and `manifest` files are generated by Fossil.
 * Enable manifest generation by visiting *Admin* > *Settings* in Fossil UI and
 * setting the *manifest* attribute to `ru`.
 *
 * \note Adapted by Lifepillar from Fossil's mkversion.c.
 */
#include <ctype.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>


static FILE* open_for_reading(char const filename[static 1]) {
  FILE* f = fopen(filename, "r");

  if (f == 0) {
    fprintf(stderr, "Cannot open \"%s\" for reading.\n", filename);
    exit(EXIT_FAILURE);
  }

  return f;
}


static void trim(char s[static 1]) { // Trim `s` at the first trailing new line
  for (; *s && *s != '\n' && *s != '\r'; ++s) { }

  *s = '\0';
}


int main(int argc, char* argv[argc + 1]) {
  if (argc != 4) {
    fprintf(stderr, "Usage: %s manifest.uuid manifest VERSION\n", argv[0]);

    return EXIT_FAILURE;
  }

  char text[1000] = {0};

  // Get manifest UUID
  FILE* manifest_uuid = open_for_reading(argv[1]);

  if (fgets(text, sizeof(text) - 1, manifest_uuid) == nullptr) {
    fprintf(stderr, "Malformed manifest.uuid file: %s\n", argv[1]);

    return EXIT_FAILURE;
  }

  fclose(manifest_uuid);

  trim(text);

  printf("#define MANIFEST_UUID \"%s\"\n", text);
  printf("#define MANIFEST_VERSION \"[%10.10s]\"\n", text);

  // Extract date and time from manifest file
  FILE* manifest = open_for_reading(argv[2]);

  while (fgets(text, sizeof(text) - 1, manifest) != nullptr) {
    if (strncmp("D ", text, 2) == 0 && strlen(text) > 20) { // E.g., 'D 2025-06-14T20:13:40.722'
      printf("#define MANIFEST_DATE \"%.10s %.8s\"\n", text + 2, text + 13);
      printf("#define MANIFEST_YEAR \"%.4s\"\n", text + 2);

      // Extract date digits
      char zDateNum[30];
      size_t n = 0;

      for (size_t k = 0; k < 10; ++k) {
        if (isdigit(text[k + 2]))
          zDateNum[n++] = text[k + 2];
      }

      zDateNum[n] = '\0';
      n = 0;

      printf("#define MANIFEST_NUMERIC_DATE %s\n", zDateNum);

      // Extract time digits
      for (size_t k = 0; k < 8; ++k) {
        if (isdigit(text[k + 13]))
          zDateNum[n++] = text[k + 13];
      }

      zDateNum[n] = '\0';

      for (n = 0; zDateNum[n] == '0'; ++n) { } // Skip leading zeroes

      printf("#define MANIFEST_NUMERIC_TIME %s\n", zDateNum + n);
    }
  }

  fclose(manifest);

  FILE* version = open_for_reading(argv[3]);

  if (fgets(text, sizeof(text) - 1, version) == nullptr) {
    fprintf(stderr, "Malformed VERSION file: %s\n", argv[3]);

    return EXIT_FAILURE;
  }

  fclose(version);

  trim(text);

  printf("\n/**\n");
  printf(" * \\brief SQLite3 Decimal short version string.\n");
  printf(" */\n");
  printf("#define SQLITE_DECIMAL_SHORT_VERSION \"%s\"\n\n", text);

  char* z = text;
  unsigned int vn[3] = {0};
  unsigned int x = 0;
  size_t j = 0;

  while (true) {
    if (z[0] >= '0' && z[0] <= '9') {
      x = x * 10 + z[0] - '0';
    }
    else {
      if (j < 3)
        vn[j++] = x;

      x = 0;

      if (z[0] == '\0')
        break;
    }

    ++z;
  }

  printf("#define RELEASE_VERSION_NUMBER %d%02d%02d\n", vn[0], vn[1], vn[2]);

  char vx[1000] = {0};
  unsigned int d = 0;

  strncpy(vx, text, 1000);

  for (z = vx; z[0]; ++z) {
    if (z[0] != '.')
      continue;

    if (d < 3) {
      z[0] = ',';
      ++d;
    }
    else {
      z[0] = '\0';
      break;
    }
  }

  printf("#define RELEASE_RESOURCE_VERSION %s", vx);

  while (d < 3) {
    printf(",0");
    ++d;
  }

  printf("\n");

#if defined(__DMC__)                       // e.g. 0x857
  d = (__DMC__ & 0xF00) >> 8;              // major
  x = (__DMC__ & 0x0F0) >> 4;              // minor
  unsigned int i = (__DMC__ & 0x00F);      // revision
  printf("#define COMPILER_VERSION \"%d.%d.%d\"\n", d, x, i);
#elif defined(__POCC__)                    // e.g. 700
  d = (__POCC__ / 100);                    // major
  x = (__POCC__ % 100);                    // minor
  printf("#define COMPILER_VERSION \"%d.%02d\"\n", d, x);
#elif defined(_MSC_VER)                    // e.g. 1800
  d = (_MSC_VER / 100);                    // major
  x = (_MSC_VER % 100);                    // minor
  printf("#define COMPILER_VERSION \"%d.%02d\"\n", d, x);
#elif defined(__clang__)
  d = (__clang_major__);
  x = (__clang_minor__);
  unsigned int i = (__clang_patchlevel__);
  printf("#define COMPILER \"clang\"\n");
  printf("#define COMPILER_VERSION \"%d.%d.%d\"\n", d, x, i);
#endif

  return EXIT_SUCCESS;
}
